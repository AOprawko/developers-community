---
pagename: Notification Protocol
redirect_from:
  - webhooks-security.html
sitesection: Documents
categoryname: "Messaging Channels"
documentname: Connector API
subfoldername: Webhooks
order: 30
indicator: messaging
permalink: connector-api-webhooks-notification-protocol.html
---

### Protocol and Security

* Webhooks notifications are sent as POST requests over TLS. Every endpoint is required to be set up with a valid server side SSL certificate supporting at least TLS version 1.3.

* Each Webhooks notification request contains LivePerson standard headers which have the header name prefix of “**x-liveperson-**”.  

* Each endpoint is expected to immediately respond to a request. A response delay of over 10 seconds will lead to a client-side read timeout. A read timeout is considered a failure which triggers the retry mechanism.

* An endpoint is expected to respond with either a 200 or 201 response code to a notification request. Any other response code will be considered as a notification request failure which triggers the retry mechanism.

### Authentication

* Each Webhook call will contain the following authentication headers:

  * **x-liveperson-account-id**: The unique LivePerson account identifier. Can be used to differentiate registration of different accounts, when the same url is used for multiple accounts.

  * **x-liveperson-client-id**: The unique client application identifier. The client_id that the consumer receives from their account manager after the App Installation process.

  * **x-liveperson-signature**: A token generated by signing the payload using the client-secret. A SHA1 signature of the payload and the **client_secret** (given by the account manager in the Application Installation process) preceded with “sha1=”. Here is an example how to calculate this signature in Java:

  ```java
    {
    Mac mac = Mac.getInstance("HmacSHAl"); 
    mac.init(**new** SecretKeySpec(
          "THE_CLIENT_SECRET".getBytes("MUTF-8"),
          "HmacSHAl"));
          System.out.println(Base64.getEncoder().encode(mac.doFinal("message payload".getBytes("UTF-8"))))
          }
  ```
